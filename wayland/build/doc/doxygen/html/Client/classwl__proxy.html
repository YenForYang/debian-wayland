<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland Client API: wl_proxy Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland Client API
   &#160;<span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">wl_proxy Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a protocol object on the client side.  
 <a href="classwl__proxy.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client-core_8h_source.html">wayland-client-core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5917991abd28c23949ad200e9399e813"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a5917991abd28c23949ad200e9399e813">wl_proxy_create</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *factory, const struct <a class="el" href="structwl__interface.html">wl_interface</a> *interface)</td></tr>
<tr class="memdesc:a5917991abd28c23949ad200e9399e813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a proxy object with a given interface.  <a href="#a5917991abd28c23949ad200e9399e813">More...</a><br /></td></tr>
<tr class="separator:a5917991abd28c23949ad200e9399e813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3fe909fed5b7ace56ca01178763381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a2d3fe909fed5b7ace56ca01178763381">wl_proxy_destroy</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:a2d3fe909fed5b7ace56ca01178763381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a proxy object.  <a href="#a2d3fe909fed5b7ace56ca01178763381">More...</a><br /></td></tr>
<tr class="separator:a2d3fe909fed5b7ace56ca01178763381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8596b88ede807f96a63c128c6e8b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a29a8596b88ede807f96a63c128c6e8b7">wl_proxy_add_listener</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, void(**implementation)(void), void *data)</td></tr>
<tr class="memdesc:a29a8596b88ede807f96a63c128c6e8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a proxy's listener.  <a href="#a29a8596b88ede807f96a63c128c6e8b7">More...</a><br /></td></tr>
<tr class="separator:a29a8596b88ede807f96a63c128c6e8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30175804b647e683773172d50812c88f"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a30175804b647e683773172d50812c88f">wl_proxy_get_listener</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:a30175804b647e683773172d50812c88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a proxy's listener.  <a href="#a30175804b647e683773172d50812c88f">More...</a><br /></td></tr>
<tr class="separator:a30175804b647e683773172d50812c88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ec4f95c2cead639976b27bf4af55c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a45ec4f95c2cead639976b27bf4af55c1">wl_proxy_add_dispatcher</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, <a class="el" href="wayland-util_8h.html#abdec454d1dffed08d355d225e21ac8bd">wl_dispatcher_func_t</a> dispatcher, const void *implementation, void *data)</td></tr>
<tr class="memdesc:a45ec4f95c2cead639976b27bf4af55c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a proxy's listener (with dispatcher)  <a href="#a45ec4f95c2cead639976b27bf4af55c1">More...</a><br /></td></tr>
<tr class="separator:a45ec4f95c2cead639976b27bf4af55c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e89b859b28d48949a1b4b00e9a39f05"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a8e89b859b28d48949a1b4b00e9a39f05">wl_proxy_marshal_array_constructor</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode, union <a class="el" href="unionwl__argument.html">wl_argument</a> *args, const struct <a class="el" href="structwl__interface.html">wl_interface</a> *interface)</td></tr>
<tr class="memdesc:a8e89b859b28d48949a1b4b00e9a39f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#a8e89b859b28d48949a1b4b00e9a39f05">More...</a><br /></td></tr>
<tr class="separator:a8e89b859b28d48949a1b4b00e9a39f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61b4c579eba754bdbefd04c0e3f8b13"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#ae61b4c579eba754bdbefd04c0e3f8b13">wl_proxy_marshal_array_constructor_versioned</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode, union <a class="el" href="unionwl__argument.html">wl_argument</a> *args, const struct <a class="el" href="structwl__interface.html">wl_interface</a> *interface, uint32_t version)</td></tr>
<tr class="memdesc:ae61b4c579eba754bdbefd04c0e3f8b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#ae61b4c579eba754bdbefd04c0e3f8b13">More...</a><br /></td></tr>
<tr class="separator:ae61b4c579eba754bdbefd04c0e3f8b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1430215e7558bfea8179c1a5d7201a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f">wl_proxy_marshal</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode,...)</td></tr>
<tr class="memdesc:a1430215e7558bfea8179c1a5d7201a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#a1430215e7558bfea8179c1a5d7201a7f">More...</a><br /></td></tr>
<tr class="separator:a1430215e7558bfea8179c1a5d7201a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d70d86a2467bf20867fb93699a6d28"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#aa2d70d86a2467bf20867fb93699a6d28">wl_proxy_marshal_constructor</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode, const struct <a class="el" href="structwl__interface.html">wl_interface</a> *interface,...)</td></tr>
<tr class="memdesc:aa2d70d86a2467bf20867fb93699a6d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#aa2d70d86a2467bf20867fb93699a6d28">More...</a><br /></td></tr>
<tr class="separator:aa2d70d86a2467bf20867fb93699a6d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397e6d324ce0c262afe09d365be2b8e2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a397e6d324ce0c262afe09d365be2b8e2">wl_proxy_marshal_constructor_versioned</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode, const struct <a class="el" href="structwl__interface.html">wl_interface</a> *interface, uint32_t version,...)</td></tr>
<tr class="memdesc:a397e6d324ce0c262afe09d365be2b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#a397e6d324ce0c262afe09d365be2b8e2">More...</a><br /></td></tr>
<tr class="separator:a397e6d324ce0c262afe09d365be2b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4cc90edff2f7bd3dfbb2db57f7d873"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a8f4cc90edff2f7bd3dfbb2db57f7d873">wl_proxy_marshal_array</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, uint32_t opcode, union <a class="el" href="unionwl__argument.html">wl_argument</a> *args)</td></tr>
<tr class="memdesc:a8f4cc90edff2f7bd3dfbb2db57f7d873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a request to be sent to the compositor.  <a href="#a8f4cc90edff2f7bd3dfbb2db57f7d873">More...</a><br /></td></tr>
<tr class="separator:a8f4cc90edff2f7bd3dfbb2db57f7d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fa4ee5b728a372cff9ac5164153fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a97fa4ee5b728a372cff9ac5164153fef">wl_proxy_set_user_data</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, void *user_data)</td></tr>
<tr class="memdesc:a97fa4ee5b728a372cff9ac5164153fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the user data associated with a proxy.  <a href="#a97fa4ee5b728a372cff9ac5164153fef">More...</a><br /></td></tr>
<tr class="separator:a97fa4ee5b728a372cff9ac5164153fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc50a9d788e0007f144a7bea7f170c3f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#abc50a9d788e0007f144a7bea7f170c3f">wl_proxy_get_user_data</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:abc50a9d788e0007f144a7bea7f170c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the user data associated with a proxy.  <a href="#abc50a9d788e0007f144a7bea7f170c3f">More...</a><br /></td></tr>
<tr class="separator:abc50a9d788e0007f144a7bea7f170c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918c3bff4543bcfd0d6cb689d0666db2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a918c3bff4543bcfd0d6cb689d0666db2">wl_proxy_get_version</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:a918c3bff4543bcfd0d6cb689d0666db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the protocol object version of a proxy object.  <a href="#a918c3bff4543bcfd0d6cb689d0666db2">More...</a><br /></td></tr>
<tr class="separator:a918c3bff4543bcfd0d6cb689d0666db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd609baf53e8691c5307fdaf12d4d176"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#acd609baf53e8691c5307fdaf12d4d176">wl_proxy_get_id</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:acd609baf53e8691c5307fdaf12d4d176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id of a proxy object.  <a href="#acd609baf53e8691c5307fdaf12d4d176">More...</a><br /></td></tr>
<tr class="separator:acd609baf53e8691c5307fdaf12d4d176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365697bb1c59f3714e5654348d7b480a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a365697bb1c59f3714e5654348d7b480a">wl_proxy_get_class</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy)</td></tr>
<tr class="memdesc:a365697bb1c59f3714e5654348d7b480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interface name (class) of a proxy object.  <a href="#a365697bb1c59f3714e5654348d7b480a">More...</a><br /></td></tr>
<tr class="separator:a365697bb1c59f3714e5654348d7b480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f51ea5d172df68f61018b2879e0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#acc5f51ea5d172df68f61018b2879e0cc">wl_proxy_set_queue</a> (struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *proxy, struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *queue)</td></tr>
<tr class="memdesc:acc5f51ea5d172df68f61018b2879e0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a proxy to an event queue.  <a href="#acc5f51ea5d172df68f61018b2879e0cc">More...</a><br /></td></tr>
<tr class="separator:acc5f51ea5d172df68f61018b2879e0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9d0eb81d1fd4931f566aed090d6f28"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#afb9d0eb81d1fd4931f566aed090d6f28">wl_proxy_create_wrapper</a> (void *proxy)</td></tr>
<tr class="memdesc:afb9d0eb81d1fd4931f566aed090d6f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a proxy wrapper for making queue assignments thread-safe.  <a href="#afb9d0eb81d1fd4931f566aed090d6f28">More...</a><br /></td></tr>
<tr class="separator:afb9d0eb81d1fd4931f566aed090d6f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0261dbfa5f690667643940ab2ec1ee99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__proxy.html#a0261dbfa5f690667643940ab2ec1ee99">wl_proxy_wrapper_destroy</a> (void *proxy_wrapper)</td></tr>
<tr class="memdesc:a0261dbfa5f690667643940ab2ec1ee99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a proxy wrapper.  <a href="#a0261dbfa5f690667643940ab2ec1ee99">More...</a><br /></td></tr>
<tr class="separator:a0261dbfa5f690667643940ab2ec1ee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a protocol object on the client side. </p>
<p>A <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> acts as a client side proxy to an object existing in the compositor. The proxy is responsible for converting requests made by the clients with <a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f">wl_proxy_marshal()</a> into Wayland's wire format. Events coming from the compositor are also handled by the proxy, which will in turn call the handler set with <a class="el" href="classwl__proxy.html#a29a8596b88ede807f96a63c128c6e8b7">wl_proxy_add_listener()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>With the exception of function <a class="el" href="classwl__proxy.html#acc5f51ea5d172df68f61018b2879e0cc">wl_proxy_set_queue()</a>, functions accessing a <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> are not normally used by client code. Clients should normally use the higher level interface generated by the scanner to interact with compositor objects. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a45ec4f95c2cead639976b27bf4af55c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ec4f95c2cead639976b27bf4af55c1">&#9670;&nbsp;</a></span>wl_proxy_add_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_proxy_add_dispatcher </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="wayland-util_8h.html#abdec454d1dffed08d355d225e21ac8bd">wl_dispatcher_func_t</a>&#160;</td>
          <td class="paramname"><em>dispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>implementation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a proxy's listener (with dispatcher) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">dispatcher</td><td>The dispatcher to be used for this proxy </td></tr>
    <tr><td class="paramname">implementation</td><td>The dispatcher-specific listener implementation </td></tr>
    <tr><td class="paramname">data</td><td>User data to be associated with the proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure</dd></dl>
<p>Set proxy's listener to use <code>dispatcher_func</code> as its dispatcher and <code>dispatcher_data</code> as its dispatcher-specific implementation and its user data to <code>data</code>. If a listener has already been set, this function fails and nothing is changed.</p>
<p>The exact details of dispatcher_data depend on the dispatcher used. This function is intended to be used by language bindings, not user code.</p>
<p><code>proxy</code> must not be a proxy wrapper. </p>

</div>
</div>
<a id="a29a8596b88ede807f96a63c128c6e8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8596b88ede807f96a63c128c6e8b7">&#9670;&nbsp;</a></span>wl_proxy_add_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_proxy_add_listener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(**)(void)&#160;</td>
          <td class="paramname"><em>implementation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a proxy's listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">implementation</td><td>The listener to be added to proxy </td></tr>
    <tr><td class="paramname">data</td><td>User data to be associated with the proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure</dd></dl>
<p>Set proxy's listener to <code>implementation</code> and its user data to <code>data</code>. If a listener has already been set, this function fails and nothing is changed.</p>
<p><code>implementation</code> is a vector of function pointers. For an opcode <code>n</code>, <code>implementation</code>[n] should point to the handler of <code>n</code> for the given object.</p>
<p><code>proxy</code> must not be a proxy wrapper. </p>

</div>
</div>
<a id="a5917991abd28c23949ad200e9399e813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5917991abd28c23949ad200e9399e813">&#9670;&nbsp;</a></span>wl_proxy_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> * wl_proxy_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a proxy object with a given interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factory</td><td>Factory proxy object </td></tr>
    <tr><td class="paramname">interface</td><td>Interface the proxy object should use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated proxy object or NULL on failure</dd></dl>
<p>This function creates a new proxy object with the supplied interface. The proxy object will have an id assigned from the client id space. The id should be created on the compositor side by sending an appropriate request with <a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f">wl_proxy_marshal()</a>.</p>
<p>The proxy will inherit the display and event queue of the factory object.</p>
<dl class="section note"><dt>Note</dt><dd>This should not normally be used by non-generated code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a>, <a class="el" href="classwl__event__queue.html" title="A queue for wl_proxy object events. ">wl_event_queue</a>, <a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal()</a> </dd></dl>

</div>
</div>
<a id="afb9d0eb81d1fd4931f566aed090d6f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9d0eb81d1fd4931f566aed090d6f28">&#9670;&nbsp;</a></span>wl_proxy_create_wrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wl_proxy_create_wrapper </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a proxy wrapper for making queue assignments thread-safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object to be wrapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A proxy wrapper for the given proxy or NULL on failure</dd></dl>
<p>A proxy wrapper is type of 'struct <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a>' instance that can be used when sending requests instead of using the original proxy. A proxy wrapper does not have an implementation or dispatcher, and events received on the object is still emitted on the original proxy. Trying to set an implementation or dispatcher will have no effect but result in a warning being logged.</p>
<p>Setting the proxy queue of the proxy wrapper will make new objects created using the proxy wrapper use the set proxy queue. Even though there is no implementation nor dispatcher, the proxy queue can be changed. This will affect the default queue of new objects created by requests sent via the proxy wrapper.</p>
<p>A proxy wrapper can only be destroyed using <a class="el" href="classwl__proxy.html#a0261dbfa5f690667643940ab2ec1ee99" title="Destroy a proxy wrapper. ">wl_proxy_wrapper_destroy()</a>.</p>
<p>A proxy wrapper must be destroyed before the proxy it was created from.</p>
<p>If a user reads and dispatches events on more than one thread, it is necessary to use a proxy wrapper when sending requests on objects when the intention is that a newly created proxy is to use a proxy queue different from the proxy the request was sent on, as creating the new proxy and then setting the queue is not thread safe.</p>
<p>For example, a module that runs using its own proxy queue that needs to do display roundtrip must wrap the <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> proxy object before sending the wl_display.sync request. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="classwl__event__queue.html">wl_event_queue</a> *queue = ...;</div><div class="line"><span class="keyword">struct </span><a class="code" href="classwl__display.html">wl_display</a> *wrapped_display;</div><div class="line"><span class="keyword">struct </span>wl_callback *callback;</div><div class="line"></div><div class="line">wrapped_display = <a class="code" href="classwl__proxy.html#afb9d0eb81d1fd4931f566aed090d6f28">wl_proxy_create_wrapper</a>(display);</div><div class="line"><a class="code" href="classwl__proxy.html#acc5f51ea5d172df68f61018b2879e0cc">wl_proxy_set_queue</a>((<span class="keyword">struct</span> <a class="code" href="classwl__proxy.html">wl_proxy</a> *) wrapped_display, queue);</div><div class="line">callback = <a class="code" href="group__iface__wl__display.html#gaa97de38d1338111935e8ba546a44a208">wl_display_sync</a>(wrapped_display);</div><div class="line"><a class="code" href="classwl__proxy.html#a0261dbfa5f690667643940ab2ec1ee99">wl_proxy_wrapper_destroy</a>(wrapped_display);</div><div class="line"><a class="code" href="group__iface__wl__callback.html#ga617feda08cd95aac95e9d07a2ee8aa65">wl_callback_add_listener</a>(callback, ...);</div></div><!-- fragment --> 
</div>
</div>
<a id="a2d3fe909fed5b7ace56ca01178763381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3fe909fed5b7ace56ca01178763381">&#9670;&nbsp;</a></span>wl_proxy_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a proxy object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy to be destroyed</td></tr>
  </table>
  </dd>
</dl>
<p><code>proxy</code> must not be a proxy wrapper. </p>

</div>
</div>
<a id="a365697bb1c59f3714e5654348d7b480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365697bb1c59f3714e5654348d7b480a">&#9670;&nbsp;</a></span>wl_proxy_get_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * wl_proxy_get_class </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interface name (class) of a proxy object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interface name of the object associated with the proxy </dd></dl>

</div>
</div>
<a id="acd609baf53e8691c5307fdaf12d4d176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd609baf53e8691c5307fdaf12d4d176">&#9670;&nbsp;</a></span>wl_proxy_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wl_proxy_get_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id of a proxy object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The id the object associated with the proxy </dd></dl>

</div>
</div>
<a id="a30175804b647e683773172d50812c88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30175804b647e683773172d50812c88f">&#9670;&nbsp;</a></span>wl_proxy_get_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * wl_proxy_get_listener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a proxy's listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the proxy's listener or NULL if no listener is set</dd></dl>
<p>Gets the address to the proxy's listener; which is the listener set with <a class="el" href="classwl__proxy.html#a29a8596b88ede807f96a63c128c6e8b7">wl_proxy_add_listener</a>.</p>
<p>This function is useful in clients with multiple listeners on the same interface to allow the identification of which code to execute. </p>

</div>
</div>
<a id="abc50a9d788e0007f144a7bea7f170c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc50a9d788e0007f144a7bea7f170c3f">&#9670;&nbsp;</a></span>wl_proxy_get_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * wl_proxy_get_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the user data associated with a proxy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The user data associated with proxy </dd></dl>

</div>
</div>
<a id="a918c3bff4543bcfd0d6cb689d0666db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918c3bff4543bcfd0d6cb689d0666db2">&#9670;&nbsp;</a></span>wl_proxy_get_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wl_proxy_get_version </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the protocol object version of a proxy object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The protocol object version of the proxy or 0</dd></dl>
<p>Gets the protocol object version of a proxy object, or 0 if the proxy was created with unversioned API.</p>
<p>A returned value of 0 means that no version information is available, so the caller must make safe assumptions about the object's real version.</p>
<p><a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a>'s version will always return 0. </p>

</div>
</div>
<a id="a1430215e7558bfea8179c1a5d7201a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1430215e7558bfea8179c1a5d7201a7f">&#9670;&nbsp;</a></span>wl_proxy_marshal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_marshal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">...</td><td>Extra arguments for the given request</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="classwl__proxy.html#aa2d70d86a2467bf20867fb93699a6d28" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal_constructor()</a>, except it doesn't create proxies for new-id arguments.</p>
<dl class="section note"><dt>Note</dt><dd>This should not normally be used by non-generated code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__proxy.html#a5917991abd28c23949ad200e9399e813" title="Create a proxy object with a given interface. ">wl_proxy_create()</a> </dd></dl>

</div>
</div>
<a id="a8f4cc90edff2f7bd3dfbb2db57f7d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4cc90edff2f7bd3dfbb2db57f7d873">&#9670;&nbsp;</a></span>wl_proxy_marshal_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_marshal_array </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionwl__argument.html">wl_argument</a> *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">args</td><td>Extra arguments for the given request</td></tr>
  </table>
  </dd>
</dl>
<p>This function is similar to <a class="el" href="classwl__proxy.html#a8e89b859b28d48949a1b4b00e9a39f05" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal_array_constructor()</a>, except it doesn't create proxies for new-id arguments.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used by language bindings and not in non-generated code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal()</a> </dd></dl>

</div>
</div>
<a id="a8e89b859b28d48949a1b4b00e9a39f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e89b859b28d48949a1b4b00e9a39f05">&#9670;&nbsp;</a></span>wl_proxy_marshal_array_constructor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> * wl_proxy_marshal_array_constructor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionwl__argument.html">wl_argument</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">args</td><td>Extra arguments for the given request </td></tr>
    <tr><td class="paramname">interface</td><td>The interface to use for the new proxy</td></tr>
  </table>
  </dd>
</dl>
<p>This function translates a request given an opcode, an interface and a <a class="el" href="unionwl__argument.html" title="Protocol message argument data types. ">wl_argument</a> array to the wire format and writes it to the connection buffer.</p>
<p>For new-id arguments, this function will allocate a new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> and send the ID to the server. The new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> will be returned on success or NULL on error with errno set accordingly. The newly created proxy will inherit their version from their parent.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used by language bindings and not in non-generated code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal()</a> </dd></dl>

</div>
</div>
<a id="ae61b4c579eba754bdbefd04c0e3f8b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61b4c579eba754bdbefd04c0e3f8b13">&#9670;&nbsp;</a></span>wl_proxy_marshal_array_constructor_versioned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> * wl_proxy_marshal_array_constructor_versioned </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">union <a class="el" href="unionwl__argument.html">wl_argument</a> *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">args</td><td>Extra arguments for the given request </td></tr>
    <tr><td class="paramname">interface</td><td>The interface to use for the new proxy </td></tr>
    <tr><td class="paramname">version</td><td>The protocol object version for the new proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Translates the request given by opcode and the extra arguments into the wire format and write it to the connection buffer. This version takes an array of the union type <a class="el" href="unionwl__argument.html" title="Protocol message argument data types. ">wl_argument</a>.</p>
<p>For new-id arguments, this function will allocate a new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> and send the ID to the server. The new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> will be returned on success or NULL on error with errno set accordingly. The newly created proxy will have the version specified.</p>
<dl class="section note"><dt>Note</dt><dd>This is intended to be used by language bindings and not in non-generated code.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__proxy.html#a1430215e7558bfea8179c1a5d7201a7f" title="Prepare a request to be sent to the compositor. ">wl_proxy_marshal()</a> </dd></dl>

</div>
</div>
<a id="aa2d70d86a2467bf20867fb93699a6d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d70d86a2467bf20867fb93699a6d28">&#9670;&nbsp;</a></span>wl_proxy_marshal_constructor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> * wl_proxy_marshal_constructor </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">interface</td><td>The interface to use for the new proxy </td></tr>
    <tr><td class="paramname">...</td><td>Extra arguments for the given request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> for the new_id argument or NULL on error</dd></dl>
<p>This function translates a request given an opcode, an interface and extra arguments to the wire format and writes it to the connection buffer. The types of the extra arguments must correspond to the argument types of the method associated with the opcode in the interface.</p>
<p>For new-id arguments, this function will allocate a new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> and send the ID to the server. The new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> will be returned on success or NULL on error with errno set accordingly. The newly created proxy will inherit their version from their parent.</p>
<dl class="section note"><dt>Note</dt><dd>This should not normally be used by non-generated code. </dd></dl>

</div>
</div>
<a id="a397e6d324ce0c262afe09d365be2b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397e6d324ce0c262afe09d365be2b8e2">&#9670;&nbsp;</a></span>wl_proxy_marshal_constructor_versioned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> * wl_proxy_marshal_constructor_versioned </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> *&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a request to be sent to the compositor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">opcode</td><td>Opcode of the request to be sent </td></tr>
    <tr><td class="paramname">interface</td><td>The interface to use for the new proxy </td></tr>
    <tr><td class="paramname">version</td><td>The protocol object version of the new proxy </td></tr>
    <tr><td class="paramname">...</td><td>Extra arguments for the given request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> for the new_id argument or NULL on error</dd></dl>
<p>Translates the request given by opcode and the extra arguments into the wire format and write it to the connection buffer.</p>
<p>For new-id arguments, this function will allocate a new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> and send the ID to the server. The new <a class="el" href="classwl__proxy.html" title="Represents a protocol object on the client side. ">wl_proxy</a> will be returned on success or NULL on error with errno set accordingly. The newly created proxy will have the version specified.</p>
<dl class="section note"><dt>Note</dt><dd>This should not normally be used by non-generated code. </dd></dl>

</div>
</div>
<a id="acc5f51ea5d172df68f61018b2879e0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5f51ea5d172df68f61018b2879e0cc">&#9670;&nbsp;</a></span>wl_proxy_set_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_set_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a proxy to an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">queue</td><td>The event queue that will handle this proxy or NULL</td></tr>
  </table>
  </dd>
</dl>
<p>Assign proxy to event queue. Events coming from <code>proxy</code> will be queued in <code>queue</code> from now. If queue is NULL, then the display's default queue is set to the proxy.</p>
<dl class="section note"><dt>Note</dt><dd>By default, the queue set in proxy is the one inherited from parent.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17" title="Dispatch events in an event queue. ">wl_display_dispatch_queue()</a> </dd></dl>

</div>
</div>
<a id="a97fa4ee5b728a372cff9ac5164153fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fa4ee5b728a372cff9ac5164153fef">&#9670;&nbsp;</a></span>wl_proxy_set_user_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_set_user_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__proxy.html">wl_proxy</a> *&#160;</td>
          <td class="paramname"><em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the user data associated with a proxy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy</td><td>The proxy object </td></tr>
    <tr><td class="paramname">user_data</td><td>The data to be associated with proxy</td></tr>
  </table>
  </dd>
</dl>
<p>Set the user data associated with <code>proxy</code>. When events for this proxy are received, <code>user_data</code> will be supplied to its listener. </p>

</div>
</div>
<a id="a0261dbfa5f690667643940ab2ec1ee99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0261dbfa5f690667643940ab2ec1ee99">&#9670;&nbsp;</a></span>wl_proxy_wrapper_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_proxy_wrapper_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>proxy_wrapper</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a proxy wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proxy_wrapper</td><td>The proxy wrapper to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="wayland-client-core_8h_source.html">wayland-client-core.h</a></li>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="wayland-client_8c.html">wayland-client.c</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 6 2018 13:02:11 for Wayland Client API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland Client API: wl_display Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland Client API
   &#160;<span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">wl_display Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a connection to the compositor and acts as a proxy to the <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> singleton object.  
 <a href="classwl__display.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-client-core_8h_source.html">wayland-client-core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a44f497851dc7bd5b683121104015ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a9a44f497851dc7bd5b683121104015ac">wl_display_create_queue</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a9a44f497851dc7bd5b683121104015ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new event queue for this display.  <a href="#a9a44f497851dc7bd5b683121104015ac">More...</a><br /></td></tr>
<tr class="separator:a9a44f497851dc7bd5b683121104015ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90663db371e1b11704be98c1568c5206"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a90663db371e1b11704be98c1568c5206">wl_display_connect_to_fd</a> (int fd)</td></tr>
<tr class="memdesc:a90663db371e1b11704be98c1568c5206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to Wayland display on an already open fd.  <a href="#a90663db371e1b11704be98c1568c5206">More...</a><br /></td></tr>
<tr class="separator:a90663db371e1b11704be98c1568c5206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048371dfef7577bd39a3c04b78d0374"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#af048371dfef7577bd39a3c04b78d0374">wl_display_connect</a> (const char *name)</td></tr>
<tr class="memdesc:af048371dfef7577bd39a3c04b78d0374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a Wayland display.  <a href="#af048371dfef7577bd39a3c04b78d0374">More...</a><br /></td></tr>
<tr class="separator:af048371dfef7577bd39a3c04b78d0374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9150a7e3213a58b469a6966e60a9f108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a9150a7e3213a58b469a6966e60a9f108">wl_display_disconnect</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a9150a7e3213a58b469a6966e60a9f108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a connection to a Wayland display.  <a href="#a9150a7e3213a58b469a6966e60a9f108">More...</a><br /></td></tr>
<tr class="separator:a9150a7e3213a58b469a6966e60a9f108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5d249e81cbf43c3521d4bce575f1ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a2d5d249e81cbf43c3521d4bce575f1ca">wl_display_get_fd</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a2d5d249e81cbf43c3521d4bce575f1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a display context's file descriptor.  <a href="#a2d5d249e81cbf43c3521d4bce575f1ca">More...</a><br /></td></tr>
<tr class="separator:a2d5d249e81cbf43c3521d4bce575f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f44c38fa4e535f5eaf700933b0b2e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a73f44c38fa4e535f5eaf700933b0b2e6">wl_display_roundtrip_queue</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display, struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *queue)</td></tr>
<tr class="memdesc:a73f44c38fa4e535f5eaf700933b0b2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all pending request are processed by the server.  <a href="#a73f44c38fa4e535f5eaf700933b0b2e6">More...</a><br /></td></tr>
<tr class="separator:a73f44c38fa4e535f5eaf700933b0b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f38c2f80980ac84f347e932793390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#ab60f38c2f80980ac84f347e932793390">wl_display_roundtrip</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:ab60f38c2f80980ac84f347e932793390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all pending request are processed by the server.  <a href="#ab60f38c2f80980ac84f347e932793390">More...</a><br /></td></tr>
<tr class="separator:ab60f38c2f80980ac84f347e932793390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1619d9b0930a6d1b70ccd1488335b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4">wl_display_read_events</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a1b1619d9b0930a6d1b70ccd1488335b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read events from display file descriptor.  <a href="#a1b1619d9b0930a6d1b70ccd1488335b4">More...</a><br /></td></tr>
<tr class="separator:a1b1619d9b0930a6d1b70ccd1488335b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40039c1169b153269a3dc0796a54ddb0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0">wl_display_prepare_read_queue</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display, struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *queue)</td></tr>
<tr class="memdesc:a40039c1169b153269a3dc0796a54ddb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to read events from the display's file descriptor to a queue.  <a href="#a40039c1169b153269a3dc0796a54ddb0">More...</a><br /></td></tr>
<tr class="separator:a40039c1169b153269a3dc0796a54ddb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040dca18775e3177883f06bd6fdf395f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f">wl_display_prepare_read</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a040dca18775e3177883f06bd6fdf395f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare to read events from the display's file descriptor.  <a href="#a040dca18775e3177883f06bd6fdf395f">More...</a><br /></td></tr>
<tr class="separator:a040dca18775e3177883f06bd6fdf395f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978fcabf13f1915e565435ab097bd590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590">wl_display_cancel_read</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a978fcabf13f1915e565435ab097bd590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel read intention on display's fd.  <a href="#a978fcabf13f1915e565435ab097bd590">More...</a><br /></td></tr>
<tr class="separator:a978fcabf13f1915e565435ab097bd590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae027b09801474ac7c6b0f1ef25ff6e17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17">wl_display_dispatch_queue</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display, struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *queue)</td></tr>
<tr class="memdesc:ae027b09801474ac7c6b0f1ef25ff6e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch events in an event queue.  <a href="#ae027b09801474ac7c6b0f1ef25ff6e17">More...</a><br /></td></tr>
<tr class="separator:ae027b09801474ac7c6b0f1ef25ff6e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a14a809eb2c083a806db2ee15523041"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041">wl_display_dispatch_queue_pending</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display, struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *queue)</td></tr>
<tr class="memdesc:a8a14a809eb2c083a806db2ee15523041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch pending events in an event queue.  <a href="#a8a14a809eb2c083a806db2ee15523041">More...</a><br /></td></tr>
<tr class="separator:a8a14a809eb2c083a806db2ee15523041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a9c4f020f3e77581c7a81ecdb4913d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d">wl_display_dispatch</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a30a9c4f020f3e77581c7a81ecdb4913d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process incoming events.  <a href="#a30a9c4f020f3e77581c7a81ecdb4913d">More...</a><br /></td></tr>
<tr class="separator:a30a9c4f020f3e77581c7a81ecdb4913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b6b5ad31932bc3830ff362d2938560"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560">wl_display_dispatch_pending</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:ac4b6b5ad31932bc3830ff362d2938560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch default queue events without reading from the display fd.  <a href="#ac4b6b5ad31932bc3830ff362d2938560">More...</a><br /></td></tr>
<tr class="separator:ac4b6b5ad31932bc3830ff362d2938560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceca1c6f280ac1308ee0e16cd186f94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a1ceca1c6f280ac1308ee0e16cd186f94">wl_display_get_error</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a1ceca1c6f280ac1308ee0e16cd186f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the last error that occurred on a display.  <a href="#a1ceca1c6f280ac1308ee0e16cd186f94">More...</a><br /></td></tr>
<tr class="separator:a1ceca1c6f280ac1308ee0e16cd186f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbec062c9430f8cbdf71a12ec443f7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a8fbec062c9430f8cbdf71a12ec443f7d">wl_display_get_protocol_error</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display, const struct <a class="el" href="structwl__interface.html">wl_interface</a> **interface, uint32_t *id)</td></tr>
<tr class="memdesc:a8fbec062c9430f8cbdf71a12ec443f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the information about a protocol error:  <a href="#a8fbec062c9430f8cbdf71a12ec443f7d">More...</a><br /></td></tr>
<tr class="separator:a8fbec062c9430f8cbdf71a12ec443f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8463b6e5f4cf9a2a3ad2d543aedcf429"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwl__display.html#a8463b6e5f4cf9a2a3ad2d543aedcf429">wl_display_flush</a> (struct <a class="el" href="classwl__display.html">wl_display</a> *display)</td></tr>
<tr class="memdesc:a8463b6e5f4cf9a2a3ad2d543aedcf429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send all buffered requests on the display to the server.  <a href="#a8463b6e5f4cf9a2a3ad2d543aedcf429">More...</a><br /></td></tr>
<tr class="separator:a8463b6e5f4cf9a2a3ad2d543aedcf429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a connection to the compositor and acts as a proxy to the <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> singleton object. </p>
<p>A <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> object represents a client connection to a Wayland compositor. It is created with either <a class="el" href="classwl__display.html#af048371dfef7577bd39a3c04b78d0374">wl_display_connect()</a> or <a class="el" href="classwl__display.html#a90663db371e1b11704be98c1568c5206">wl_display_connect_to_fd()</a>. A connection is terminated using <a class="el" href="classwl__display.html#a9150a7e3213a58b469a6966e60a9f108">wl_display_disconnect()</a>.</p>
<p>A <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> is also used as the <a class="el" href="classwl__proxy.html">wl_proxy</a> for the <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> singleton object on the compositor side.</p>
<p>A <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> object handles all the data sent from and to the compositor. When a <a class="el" href="classwl__proxy.html">wl_proxy</a> marshals a request, it will write its wire representation to the display's write buffer. The data is sent to the compositor when the client calls <a class="el" href="classwl__display.html#a8463b6e5f4cf9a2a3ad2d543aedcf429">wl_display_flush()</a>.</p>
<p>Incoming data is handled in two steps: queueing and dispatching. In the queue step, the data coming from the display fd is interpreted and added to a queue. On the dispatch step, the handler for the incoming event set by the client on the corresponding <a class="el" href="classwl__proxy.html">wl_proxy</a> is called.</p>
<p>A <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> has at least one event queue, called the <em>default queue</em>. Clients can create additional event queues with <a class="el" href="classwl__display.html#a9a44f497851dc7bd5b683121104015ac">wl_display_create_queue()</a> and assign <a class="el" href="classwl__proxy.html">wl_proxy</a>'s to it. Events occurring in a particular proxy are always queued in its assigned queue. A client can ensure that a certain assumption, such as holding a lock or running from a given thread, is true when a proxy event handler is called by assigning that proxy to an event queue and making sure that this queue is only dispatched when the assumption holds.</p>
<p>The default queue is dispatched by calling <a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d">wl_display_dispatch()</a>. This will dispatch any events queued on the default queue and attempt to read from the display fd if it's empty. Events read are then queued on the appropriate queues according to the proxy assignment.</p>
<p>A user created queue is dispatched with <a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17">wl_display_dispatch_queue()</a>. This function behaves exactly the same as <a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d" title="Process incoming events. ">wl_display_dispatch()</a> but it dispatches given queue instead of the default queue.</p>
<p>A real world example of event queue usage is Mesa's implementation of eglSwapBuffers() for the Wayland platform. This function might need to block until a frame callback is received, but dispatching the default queue could cause an event handler on the client to start drawing again. This problem is solved using another event queue, so that only the events handled by the EGL code are dispatched during the block.</p>
<p>This creates a problem where a thread dispatches a non-default queue, reading all the data from the display fd. If the application would call <em>poll(2)</em> after that it would block, even though there might be events queued on the default queue. Those events should be dispatched with <a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560">wl_display_dispatch_pending()</a> or <a class="el" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041">wl_display_dispatch_queue_pending()</a> before flushing and blocking. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a978fcabf13f1915e565435ab097bd590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978fcabf13f1915e565435ab097bd590">&#9670;&nbsp;</a></span>wl_display_cancel_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_display_cancel_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel read intention on display's fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object</td></tr>
  </table>
  </dd>
</dl>
<p>After a thread successfully called <a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a> it must either call <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a> or <a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a>. If the threads do not follow this rule it will lead to deadlock.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a>, <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a> </dd></dl>

</div>
</div>
<a id="af048371dfef7577bd39a3c04b78d0374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af048371dfef7577bd39a3c04b78d0374">&#9670;&nbsp;</a></span>wl_display_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__display.html">wl_display</a> * wl_display_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a Wayland display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the Wayland display to connect to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classwl__display.html">wl_display</a> object or <code>NULL</code> on failure</dd></dl>
<p>Connect to the Wayland display named <code>name</code>. If <code>name</code> is <code>NULL</code>, its value will be replaced with the WAYLAND_DISPLAY environment variable if it is set, otherwise display "wayland-0" will be used.</p>
<p>If <code>name</code> is an absolute path, then that path is used as-is for the location of the socket at which the Wayland server is listening; no qualification inside XDG_RUNTIME_DIR is attempted.</p>
<p>If <code>name</code> is <code>NULL</code> and the WAYLAND_DISPLAY environment variable is set to an absolute pathname, then that pathname is used as-is for the socket in the same manner as if <code>name</code> held an absolute path. Support for absolute paths in <code>name</code> and WAYLAND_DISPLAY is present since Wayland version 1.15. </p>

</div>
</div>
<a id="a90663db371e1b11704be98c1568c5206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90663db371e1b11704be98c1568c5206">&#9670;&nbsp;</a></span>wl_display_connect_to_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__display.html">wl_display</a> * wl_display_connect_to_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to Wayland display on an already open fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The fd to use for the connection </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classwl__display.html">wl_display</a> object or <code>NULL</code> on failure</dd></dl>
<p>The <a class="el" href="classwl__display.html" title="Represents a connection to the compositor and acts as a proxy to the wl_display singleton object...">wl_display</a> takes ownership of the fd and will close it when the display is destroyed. The fd will also be closed in case of failure. </p>

</div>
</div>
<a id="a9a44f497851dc7bd5b683121104015ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a44f497851dc7bd5b683121104015ac">&#9670;&nbsp;</a></span>wl_display_create_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> * wl_display_create_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new event queue for this display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new event queue associated with this display or NULL on failure. </dd></dl>

</div>
</div>
<a id="a9150a7e3213a58b469a6966e60a9f108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9150a7e3213a58b469a6966e60a9f108">&#9670;&nbsp;</a></span>wl_display_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_display_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a connection to a Wayland display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object</td></tr>
  </table>
  </dd>
</dl>
<p>Close the connection to <code>display</code> and free all resources associated with it. </p>

</div>
</div>
<a id="a30a9c4f020f3e77581c7a81ecdb4913d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a9c4f020f3e77581c7a81ecdb4913d">&#9670;&nbsp;</a></span>wl_display_dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_dispatch </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process incoming events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events on success or -1 on failure</dd></dl>
<p>Dispatch events on the default event queue.</p>
<p>If the default event queue is empty, this function blocks until there are events to be read from the display fd. Events are read and queued on the appropriate event queues. Finally, events on the default event queue are dispatched. On failure -1 is returned and errno set appropriately.</p>
<p>In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this function, as doing so might cause a dead lock. If external reliance on poll() (or equivalent) is required, see <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> of how to do so.</p>
<p>This function is thread safe as long as it dispatches the right queue on the right thread. It is also compatible with the multi thread event reading preparation API (see <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a>), and uses the equivalent functionality internally. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock.</p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to check if there are events on the queue or not. For dispatching default queue events without blocking, see <a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560">wl_display_dispatch_pending()</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560" title="Dispatch default queue events without reading from the display fd. ">wl_display_dispatch_pending()</a>, <a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17" title="Dispatch events in an event queue. ">wl_display_dispatch_queue()</a>, <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a> </dd></dl>

</div>
</div>
<a id="ac4b6b5ad31932bc3830ff362d2938560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b6b5ad31932bc3830ff362d2938560">&#9670;&nbsp;</a></span>wl_display_dispatch_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_dispatch_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch default queue events without reading from the display fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events or -1 on failure</dd></dl>
<p>This function dispatches events on the main event queue. It does not attempt to read the display fd and simply returns zero if the main queue is empty, i.e., it doesn't block.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d" title="Process incoming events. ">wl_display_dispatch()</a>, <a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17" title="Dispatch events in an event queue. ">wl_display_dispatch_queue()</a>, <a class="el" href="classwl__display.html#a8463b6e5f4cf9a2a3ad2d543aedcf429" title="Send all buffered requests on the display to the server. ">wl_display_flush()</a> </dd></dl>

</div>
</div>
<a id="ae027b09801474ac7c6b0f1ef25ff6e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae027b09801474ac7c6b0f1ef25ff6e17">&#9670;&nbsp;</a></span>wl_display_dispatch_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_dispatch_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch events in an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
    <tr><td class="paramname">queue</td><td>The event queue to dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events on success or -1 on failure</dd></dl>
<p>Dispatch events on the given event queue.</p>
<p>If the given event queue is empty, this function blocks until there are events to be read from the display fd. Events are read and queued on the appropriate event queues. Finally, events on given event queue are dispatched. On failure -1 is returned and errno set appropriately.</p>
<p>In a multi threaded environment, do not manually wait using poll() (or equivalent) before calling this function, as doing so might cause a dead lock. If external reliance on poll() (or equivalent) is required, see <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> of how to do so.</p>
<p>This function is thread safe as long as it dispatches the right queue on the right thread. It is also compatible with the multi thread event reading preparation API (see <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a>), and uses the equivalent functionality internally. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock.</p>
<p>It can be used as a helper function to ease the procedure of reading and dispatching events.</p>
<dl class="section note"><dt>Note</dt><dd>Since Wayland 1.5 the display has an extra queue for its own events (i. e. delete_id). This queue is dispatched always, no matter what queue we passed as an argument to this function. That means that this function can return non-0 value even when it haven't dispatched any event for the given queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d" title="Process incoming events. ">wl_display_dispatch()</a>, <a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560" title="Dispatch default queue events without reading from the display fd. ">wl_display_dispatch_pending()</a>, <a class="el" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041" title="Dispatch pending events in an event queue. ">wl_display_dispatch_queue_pending()</a>, <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> </dd></dl>

</div>
</div>
<a id="a8a14a809eb2c083a806db2ee15523041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a14a809eb2c083a806db2ee15523041">&#9670;&nbsp;</a></span>wl_display_dispatch_queue_pending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_dispatch_queue_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch pending events in an event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
    <tr><td class="paramname">queue</td><td>The event queue to dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events on success or -1 on failure</dd></dl>
<p>Dispatch all incoming events for objects assigned to the given event queue. On failure -1 is returned and errno set appropriately. If there are no events queued, this function returns immediately.</p>
<dl class="section since"><dt>Since</dt><dd>1.0.2 </dd></dl>

</div>
</div>
<a id="a8463b6e5f4cf9a2a3ad2d543aedcf429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8463b6e5f4cf9a2a3ad2d543aedcf429">&#9670;&nbsp;</a></span>wl_display_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_flush </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send all buffered requests on the display to the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent on success or -1 on failure</dd></dl>
<p>Send all buffered data on the client side to the server. Clients should always call this function before blocking on input from the display fd. On success, the number of bytes sent to the server is returned. On failure, this function returns -1 and errno is set appropriately.</p>
<p><a class="el" href="classwl__display.html#a8463b6e5f4cf9a2a3ad2d543aedcf429" title="Send all buffered requests on the display to the server. ">wl_display_flush()</a> never blocks. It will write as much data as possible, but if all data could not be written, errno will be set to EAGAIN and -1 returned. In that case, use poll on the display file descriptor to wait for it to become writable again. </p>

</div>
</div>
<a id="a1ceca1c6f280ac1308ee0e16cd186f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ceca1c6f280ac1308ee0e16cd186f94">&#9670;&nbsp;</a></span>wl_display_get_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_get_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the last error that occurred on a display. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last error that occurred on <code>display</code> or 0 if no error occurred</dd></dl>
<p>Return the last error that occurred on the display. This may be an error sent by the server or caused by the local client.</p>
<dl class="section note"><dt>Note</dt><dd>Errors are <b>fatal</b>. If this function returns non-zero the display can no longer be used. </dd></dl>

</div>
</div>
<a id="a2d5d249e81cbf43c3521d4bce575f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5d249e81cbf43c3521d4bce575f1ca">&#9670;&nbsp;</a></span>wl_display_get_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_get_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a display context's file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Display object file descriptor</dd></dl>
<p>Return the file descriptor associated with a display so it can be integrated into the client's main loop. </p>

</div>
</div>
<a id="a8fbec062c9430f8cbdf71a12ec443f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbec062c9430f8cbdf71a12ec443f7d">&#9670;&nbsp;</a></span>wl_display_get_protocol_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t wl_display_get_protocol_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structwl__interface.html">wl_interface</a> **&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the information about a protocol error: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The Wayland display </td></tr>
    <tr><td class="paramname">interface</td><td>if not NULL, stores the interface where the error occurred, or NULL, if unknown. </td></tr>
    <tr><td class="paramname">id</td><td>if not NULL, stores the object id that generated the error, or 0, if the object id is unknown. There's no guarantee the object is still valid; the client must know if it deleted the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error code as defined in the interface specification.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> err = <a class="code" href="classwl__display.html#a1ceca1c6f280ac1308ee0e16cd186f94">wl_display_get_error</a>(display);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (err == EPROTO) {</div><div class="line">       code = <a class="code" href="classwl__display.html#a8fbec062c9430f8cbdf71a12ec443f7d">wl_display_get_protocol_error</a>(display, &amp;interface, &amp;<span class="keywordtype">id</span>);</div><div class="line">       handle_error(code, interface, <span class="keywordtype">id</span>);</div><div class="line">}</div><div class="line"></div><div class="line">...</div></div><!-- fragment --> 
</div>
</div>
<a id="a040dca18775e3177883f06bd6fdf395f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040dca18775e3177883f06bd6fdf395f">&#9670;&nbsp;</a></span>wl_display_prepare_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_prepare_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare to read events from the display's file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 if event queue was not empty</dd></dl>
<p>This function does the same thing as <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> with the default queue passed as the queue.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue</a> </dd></dl>

</div>
</div>
<a id="a40039c1169b153269a3dc0796a54ddb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40039c1169b153269a3dc0796a54ddb0">&#9670;&nbsp;</a></span>wl_display_prepare_read_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_prepare_read_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare to read events from the display's file descriptor to a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
    <tr><td class="paramname">queue</td><td>The event queue to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 if event queue was not empty</dd></dl>
<p>This function (or <a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a>) must be called before reading from the file descriptor using <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>. Calling <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> announces the calling thread's intention to read and ensures that until the thread is ready to read and calls <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>, no other thread will read from the file descriptor. This only succeeds if the event queue is empty, and if not -1 is returned and errno set to EAGAIN.</p>
<p>If a thread successfully calls <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a>, it must either call <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a> when it's ready or cancel the read intention by calling <a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a>.</p>
<p>Use this function before polling on the display fd or integrate the fd into a toolkit event loop in a race-free way. A correct usage would be (with most error checking left out):</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (<a class="code" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0">wl_display_prepare_read_queue</a>(display, queue) != 0)</div><div class="line">        <a class="code" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041">wl_display_dispatch_queue_pending</a>(display, queue);</div><div class="line"><a class="code" href="classwl__display.html#a8463b6e5f4cf9a2a3ad2d543aedcf429">wl_display_flush</a>(display);</div><div class="line"></div><div class="line">ret = poll(fds, nfds, -1);</div><div class="line"><span class="keywordflow">if</span> (has_error(ret))</div><div class="line">        <a class="code" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590">wl_display_cancel_read</a>(display);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">        <a class="code" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4">wl_display_read_events</a>(display);</div><div class="line"></div><div class="line"><a class="code" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041">wl_display_dispatch_queue_pending</a>(display, queue);</div></div><!-- fragment --><p>Here we call <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a>, which ensures that between returning from that call and eventually calling <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>, no other thread will read from the fd and queue events in our queue. If the call to <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> fails, we dispatch the pending events and try again until we're successful.</p>
<p>The <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> function doesn't acquire exclusive access to the display's fd. It only registers that the thread calling this function has intention to read from fd. When all registered readers call <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>, only one (at random) eventually reads and queues the events and the others are sleeping meanwhile. This way we avoid races and still can read from more threads.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a>, <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>, <a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a> </dd></dl>

</div>
</div>
<a id="a1b1619d9b0930a6d1b70ccd1488335b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1619d9b0930a6d1b70ccd1488335b4">&#9670;&nbsp;</a></span>wl_display_read_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_read_events </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read events from display file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on error. In case of error errno will be set accordingly</dd></dl>
<p>Calling this function will result in data available on the display file descriptor being read and read events will be queued on their corresponding event queues.</p>
<p>Before calling this function, depending on what thread it is to be called from, <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> or <a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a> needs to be called. See <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> for more details.</p>
<p>When being called at a point where other threads have been prepared to read (using <a class="el" href="classwl__display.html#a40039c1169b153269a3dc0796a54ddb0" title="Prepare to read events from the display&#39;s file descriptor to a queue. ">wl_display_prepare_read_queue()</a> or <a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a>) this function will sleep until all other prepared threads have either been cancelled (using <a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a>) or them self entered this function. The last thread that calls this function will then read and queue events on their corresponding event queues, and finally wake up all other <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a> calls causing them to return.</p>
<p>If a thread cancels a read preparation when all other threads that have prepared to read has either called <a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a> or <a class="el" href="classwl__display.html#a1b1619d9b0930a6d1b70ccd1488335b4" title="Read events from display file descriptor. ">wl_display_read_events()</a>, all reader threads will return without having read any data.</p>
<p>To dispatch events that may have been queued, call <a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560" title="Dispatch default queue events without reading from the display fd. ">wl_display_dispatch_pending()</a> or <a class="el" href="classwl__display.html#a8a14a809eb2c083a806db2ee15523041" title="Dispatch pending events in an event queue. ">wl_display_dispatch_queue_pending()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#a040dca18775e3177883f06bd6fdf395f" title="Prepare to read events from the display&#39;s file descriptor. ">wl_display_prepare_read()</a>, <a class="el" href="classwl__display.html#a978fcabf13f1915e565435ab097bd590" title="Cancel read intention on display&#39;s fd. ">wl_display_cancel_read()</a>, <a class="el" href="classwl__display.html#ac4b6b5ad31932bc3830ff362d2938560" title="Dispatch default queue events without reading from the display fd. ">wl_display_dispatch_pending()</a>, <a class="el" href="classwl__display.html#a30a9c4f020f3e77581c7a81ecdb4913d" title="Process incoming events. ">wl_display_dispatch()</a> </dd></dl>

</div>
</div>
<a id="ab60f38c2f80980ac84f347e932793390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f38c2f80980ac84f347e932793390">&#9670;&nbsp;</a></span>wl_display_roundtrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_roundtrip </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until all pending request are processed by the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events on success or -1 on failure</dd></dl>
<p>This function blocks until the server has processed all currently issued requests by sending a request to the display server and waiting for a reply before returning.</p>
<p>This function uses <a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17" title="Dispatch events in an event queue. ">wl_display_dispatch_queue()</a> internally. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock.</p>
<dl class="section note"><dt>Note</dt><dd>This function may dispatch other events being received on the default queue. </dd></dl>

</div>
</div>
<a id="a73f44c38fa4e535f5eaf700933b0b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f44c38fa4e535f5eaf700933b0b2e6">&#9670;&nbsp;</a></span>wl_display_roundtrip_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_display_roundtrip_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="classwl__display.html">wl_display</a> *&#160;</td>
          <td class="paramname"><em>display</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="classwl__event__queue.html">wl_event_queue</a> *&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block until all pending request are processed by the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display</td><td>The display context object </td></tr>
    <tr><td class="paramname">queue</td><td>The queue on which to run the roundtrip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dispatched events on success or -1 on failure</dd></dl>
<p>This function blocks until the server has processed all currently issued requests by sending a request to the display server and waiting for a reply before returning.</p>
<p>This function uses <a class="el" href="classwl__display.html#ae027b09801474ac7c6b0f1ef25ff6e17" title="Dispatch events in an event queue. ">wl_display_dispatch_queue()</a> internally. It is not allowed to call this function while the thread is being prepared for reading events, and doing so will cause a dead lock.</p>
<dl class="section note"><dt>Note</dt><dd>This function may dispatch other events being received on the given queue.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classwl__display.html#ab60f38c2f80980ac84f347e932793390" title="Block until all pending request are processed by the server. ">wl_display_roundtrip()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="wayland-client-core_8h_source.html">wayland-client-core.h</a></li>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="wayland-client_8c.html">wayland-client.c</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 6 2018 13:02:11 for Wayland Client API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>

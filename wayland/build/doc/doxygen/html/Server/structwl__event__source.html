<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wayland Server API: wl_event_source Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wayland Server API
   &#160;<span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">wl_event_source Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract event source.  
 <a href="structwl__event__source.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="wayland-server-core_8h_source.html">wayland-server-core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a09e702384ed869548c72f3576399c581"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a09e702384ed869548c72f3576399c581">wl_event_loop_fd_func_t</a>) (int fd, uint32_t mask, void *data)</td></tr>
<tr class="memdesc:a09e702384ed869548c72f3576399c581"><td class="mdescLeft">&#160;</td><td class="mdescRight">File descriptor dispatch function type.  <a href="#a09e702384ed869548c72f3576399c581">More...</a><br /></td></tr>
<tr class="separator:a09e702384ed869548c72f3576399c581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bc490bf28b48e0af908ab91649938a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a59bc490bf28b48e0af908ab91649938a">wl_event_loop_timer_func_t</a>) (void *data)</td></tr>
<tr class="memdesc:a59bc490bf28b48e0af908ab91649938a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer dispatch function type.  <a href="#a59bc490bf28b48e0af908ab91649938a">More...</a><br /></td></tr>
<tr class="separator:a59bc490bf28b48e0af908ab91649938a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431b418976144a8ebe6b19bc24206d20"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a431b418976144a8ebe6b19bc24206d20">wl_event_loop_signal_func_t</a>) (int signal_number, void *data)</td></tr>
<tr class="memdesc:a431b418976144a8ebe6b19bc24206d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal dispatch function type.  <a href="#a431b418976144a8ebe6b19bc24206d20">More...</a><br /></td></tr>
<tr class="separator:a431b418976144a8ebe6b19bc24206d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae526dfa099f9ba69285e275c82794a9b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#ae526dfa099f9ba69285e275c82794a9b">wl_event_loop_idle_func_t</a>) (void *data)</td></tr>
<tr class="memdesc:ae526dfa099f9ba69285e275c82794a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle task function type.  <a href="#ae526dfa099f9ba69285e275c82794a9b">More...</a><br /></td></tr>
<tr class="separator:ae526dfa099f9ba69285e275c82794a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e7ce1f52dfe04c73b6a7c2263c7ef25"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a0e7ce1f52dfe04c73b6a7c2263c7ef25">wl_event_loop_add_fd</a> (struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *loop, int fd, uint32_t mask, <a class="el" href="structwl__event__source.html#a09e702384ed869548c72f3576399c581">wl_event_loop_fd_func_t</a> func, void *data)</td></tr>
<tr class="memdesc:a0e7ce1f52dfe04c73b6a7c2263c7ef25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file descriptor event source.  <a href="#a0e7ce1f52dfe04c73b6a7c2263c7ef25">More...</a><br /></td></tr>
<tr class="separator:a0e7ce1f52dfe04c73b6a7c2263c7ef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe73f9ff59d489e9f27eb9c0e3058a02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#afe73f9ff59d489e9f27eb9c0e3058a02">wl_event_source_fd_update</a> (struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *source, uint32_t mask)</td></tr>
<tr class="memdesc:afe73f9ff59d489e9f27eb9c0e3058a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a file descriptor source's event mask.  <a href="#afe73f9ff59d489e9f27eb9c0e3058a02">More...</a><br /></td></tr>
<tr class="separator:afe73f9ff59d489e9f27eb9c0e3058a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39374f19a73472f63fab4267a14adc10"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a39374f19a73472f63fab4267a14adc10">wl_event_loop_add_timer</a> (struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *loop, <a class="el" href="structwl__event__source.html#a59bc490bf28b48e0af908ab91649938a">wl_event_loop_timer_func_t</a> func, void *data)</td></tr>
<tr class="memdesc:a39374f19a73472f63fab4267a14adc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a timer event source.  <a href="#a39374f19a73472f63fab4267a14adc10">More...</a><br /></td></tr>
<tr class="separator:a39374f19a73472f63fab4267a14adc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0164a47e9e8356af90c9d5c1de9f5487"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a0164a47e9e8356af90c9d5c1de9f5487">wl_event_source_timer_update</a> (struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *source, int ms_delay)</td></tr>
<tr class="memdesc:a0164a47e9e8356af90c9d5c1de9f5487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm or disarm a timer.  <a href="#a0164a47e9e8356af90c9d5c1de9f5487">More...</a><br /></td></tr>
<tr class="separator:a0164a47e9e8356af90c9d5c1de9f5487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706e2490502a95f24ccb59cbae3e2f8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a1706e2490502a95f24ccb59cbae3e2f8">wl_event_loop_add_signal</a> (struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *loop, int signal_number, <a class="el" href="structwl__event__source.html#a431b418976144a8ebe6b19bc24206d20">wl_event_loop_signal_func_t</a> func, void *data)</td></tr>
<tr class="memdesc:a1706e2490502a95f24ccb59cbae3e2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a POSIX signal event source.  <a href="#a1706e2490502a95f24ccb59cbae3e2f8">More...</a><br /></td></tr>
<tr class="separator:a1706e2490502a95f24ccb59cbae3e2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d88ae62b26a25f709977c45b300716"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#a90d88ae62b26a25f709977c45b300716">wl_event_loop_add_idle</a> (struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *loop, <a class="el" href="structwl__event__source.html#ae526dfa099f9ba69285e275c82794a9b">wl_event_loop_idle_func_t</a> func, void *data)</td></tr>
<tr class="memdesc:a90d88ae62b26a25f709977c45b300716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an idle task.  <a href="#a90d88ae62b26a25f709977c45b300716">More...</a><br /></td></tr>
<tr class="separator:a90d88ae62b26a25f709977c45b300716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa079264c57dd12168c691c000724efcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#aa079264c57dd12168c691c000724efcf">wl_event_source_check</a> (struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *source)</td></tr>
<tr class="memdesc:aa079264c57dd12168c691c000724efcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark event source to be re-checked.  <a href="#aa079264c57dd12168c691c000724efcf">More...</a><br /></td></tr>
<tr class="separator:aa079264c57dd12168c691c000724efcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe37015d67b81ae82609f2b8aa78cc4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwl__event__source.html#afe37015d67b81ae82609f2b8aa78cc4f">wl_event_source_remove</a> (struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *source)</td></tr>
<tr class="memdesc:afe37015d67b81ae82609f2b8aa78cc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an event source from its event loop.  <a href="#afe37015d67b81ae82609f2b8aa78cc4f">More...</a><br /></td></tr>
<tr class="separator:afe37015d67b81ae82609f2b8aa78cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract event source. </p>
<p>This is the generic type for fd, timer, signal, and idle sources. Functions that operate on specific source types must not be used with a different type, even if the function signature allows it. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a09e702384ed869548c72f3576399c581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e702384ed869548c72f3576399c581">&#9670;&nbsp;</a></span>wl_event_loop_fd_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wl_event_loop_fd_func_t) (int fd, uint32_t mask, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>File descriptor dispatch function type. </p>
<p>Functions of this type are used as callbacks for file descriptor events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file descriptor delivering the event. </td></tr>
    <tr><td class="paramname">mask</td><td>Describes the kind of the event as a bitwise-or of: <code>WL_EVENT_READABLE</code>, <code>WL_EVENT_WRITABLE</code>, <code>WL_EVENT_HANGUP</code>, <code>WL_EVENT_ERROR</code>. </td></tr>
    <tr><td class="paramname">data</td><td>The user data argument of the related <a class="el" href="structwl__event__source.html#a0e7ce1f52dfe04c73b6a7c2263c7ef25" title="Create a file descriptor event source. ">wl_event_loop_add_fd()</a> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the event source is registered for re-check with <a class="el" href="structwl__event__source.html#aa079264c57dd12168c691c000724efcf" title="Mark event source to be re-checked. ">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a0e7ce1f52dfe04c73b6a7c2263c7ef25" title="Create a file descriptor event source. ">wl_event_loop_add_fd()</a> </dd></dl>

</div>
</div>
<a id="ae526dfa099f9ba69285e275c82794a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae526dfa099f9ba69285e275c82794a9b">&#9670;&nbsp;</a></span>wl_event_loop_idle_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* wl_event_loop_idle_func_t) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Idle task function type. </p>
<p>Functions of this type are used as callbacks before blocking in <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data argument of the related <a class="el" href="structwl__event__source.html#a90d88ae62b26a25f709977c45b300716" title="Create an idle task. ">wl_event_loop_add_idle()</a> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a90d88ae62b26a25f709977c45b300716" title="Create an idle task. ">wl_event_loop_add_idle()</a> <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a> </dd></dl>

</div>
</div>
<a id="a431b418976144a8ebe6b19bc24206d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431b418976144a8ebe6b19bc24206d20">&#9670;&nbsp;</a></span>wl_event_loop_signal_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wl_event_loop_signal_func_t) (int signal_number, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal dispatch function type. </p>
<p>Functions of this type are used as callbacks for (POSIX) signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_number</td><td></td></tr>
    <tr><td class="paramname">data</td><td>The user data argument of the related <a class="el" href="structwl__event__source.html#a1706e2490502a95f24ccb59cbae3e2f8" title="Create a POSIX signal event source. ">wl_event_loop_add_signal()</a> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the event source is registered for re-check with <a class="el" href="structwl__event__source.html#aa079264c57dd12168c691c000724efcf" title="Mark event source to be re-checked. ">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a1706e2490502a95f24ccb59cbae3e2f8" title="Create a POSIX signal event source. ">wl_event_loop_add_signal()</a> </dd></dl>

</div>
</div>
<a id="a59bc490bf28b48e0af908ab91649938a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bc490bf28b48e0af908ab91649938a">&#9670;&nbsp;</a></span>wl_event_loop_timer_func_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* wl_event_loop_timer_func_t) (void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timer dispatch function type. </p>
<p>Functions of this type are used as callbacks for timer expiry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data argument of the related <a class="el" href="structwl__event__source.html#a39374f19a73472f63fab4267a14adc10" title="Create a timer event source. ">wl_event_loop_add_timer()</a> call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the event source is registered for re-check with <a class="el" href="structwl__event__source.html#aa079264c57dd12168c691c000724efcf" title="Mark event source to be re-checked. ">wl_event_source_check()</a>: 0 for all done, 1 for needing a re-check. If not registered, the return value is ignored and should be zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a39374f19a73472f63fab4267a14adc10" title="Create a timer event source. ">wl_event_loop_add_timer()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0e7ce1f52dfe04c73b6a7c2263c7ef25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7ce1f52dfe04c73b6a7c2263c7ef25">&#9670;&nbsp;</a></span>wl_event_loop_add_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> * wl_event_loop_add_fd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwl__event__source.html#a09e702384ed869548c72f3576399c581">wl_event_loop_fd_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a file descriptor event source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>The event loop that will process the new source. </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor to watch. </td></tr>
    <tr><td class="paramname">mask</td><td>A bitwise-or of which events to watch for: <code>WL_EVENT_READABLE</code>, <code>WL_EVENT_WRITABLE</code>. </td></tr>
    <tr><td class="paramname">func</td><td>The file descriptor dispatch function. </td></tr>
    <tr><td class="paramname">data</td><td>User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new file descriptor event source.</dd></dl>
<p>The given file descriptor is initially watched for the events given in <code>mask</code>. This can be changed as needed with <a class="el" href="structwl__event__source.html#afe73f9ff59d489e9f27eb9c0e3058a02" title="Update a file descriptor source&#39;s event mask. ">wl_event_source_fd_update()</a>.</p>
<p>If it is possible that program execution causes the file descriptor to be read while leaving the data in a buffer without actually processing it, it may be necessary to register the file descriptor source to be re-checked, see <a class="el" href="structwl__event__source.html#aa079264c57dd12168c691c000724efcf" title="Mark event source to be re-checked. ">wl_event_source_check()</a>. This will ensure that the dispatch function gets called even if the file descriptor is not readable or writable anymore. This is especially useful with IPC libraries that automatically buffer incoming data, possibly as a side-effect of other operations.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a09e702384ed869548c72f3576399c581" title="File descriptor dispatch function type. ">wl_event_loop_fd_func_t</a> </dd></dl>

</div>
</div>
<a id="a90d88ae62b26a25f709977c45b300716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d88ae62b26a25f709977c45b300716">&#9670;&nbsp;</a></span>wl_event_loop_add_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> * wl_event_loop_add_idle </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwl__event__source.html#ae526dfa099f9ba69285e275c82794a9b">wl_event_loop_idle_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an idle task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>The event loop that will process the new task. </td></tr>
    <tr><td class="paramname">func</td><td>The idle task dispatch function. </td></tr>
    <tr><td class="paramname">data</td><td>User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new idle task (an event source).</dd></dl>
<p>Idle tasks are dispatched before <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a> goes to sleep. See <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a> for more details.</p>
<p>Idle tasks fire once, and are automatically destroyed right after the callback function has been called.</p>
<p>An idle task can be cancelled before the callback has been called by <a class="el" href="structwl__event__source.html#afe37015d67b81ae82609f2b8aa78cc4f" title="Remove an event source from its event loop. ">wl_event_source_remove()</a>. Calling <a class="el" href="structwl__event__source.html#afe37015d67b81ae82609f2b8aa78cc4f" title="Remove an event source from its event loop. ">wl_event_source_remove()</a> after or from within the callback results in undefined behaviour.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#ae526dfa099f9ba69285e275c82794a9b" title="Idle task function type. ">wl_event_loop_idle_func_t</a> </dd></dl>

</div>
</div>
<a id="a1706e2490502a95f24ccb59cbae3e2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1706e2490502a95f24ccb59cbae3e2f8">&#9670;&nbsp;</a></span>wl_event_loop_add_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> * wl_event_loop_add_signal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signal_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwl__event__source.html#a431b418976144a8ebe6b19bc24206d20">wl_event_loop_signal_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a POSIX signal event source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>The event loop that will process the new source. </td></tr>
    <tr><td class="paramname">signal_number</td><td>Number of the signal to watch for. </td></tr>
    <tr><td class="paramname">func</td><td>The signal dispatch function. </td></tr>
    <tr><td class="paramname">data</td><td>User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new signal event source.</dd></dl>
<p>This function blocks the normal delivery of the given signal in the calling thread, and creates a "watch" for it. Signal delivery no longer happens asynchronously, but by <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a> calling the dispatch callback function <code>func</code>.</p>
<p>It is the caller's responsibility to ensure that all other threads have also blocked the signal.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a431b418976144a8ebe6b19bc24206d20" title="Signal dispatch function type. ">wl_event_loop_signal_func_t</a> </dd></dl>

</div>
</div>
<a id="a39374f19a73472f63fab4267a14adc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39374f19a73472f63fab4267a14adc10">&#9670;&nbsp;</a></span>wl_event_loop_add_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> * wl_event_loop_add_timer </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__loop.html">wl_event_loop</a> *&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwl__event__source.html#a59bc490bf28b48e0af908ab91649938a">wl_event_loop_timer_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a timer event source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>The event loop that will process the new source. </td></tr>
    <tr><td class="paramname">func</td><td>The timer dispatch function. </td></tr>
    <tr><td class="paramname">data</td><td>User data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new timer event source.</dd></dl>
<p>The timer is initially disarmed. It needs to be armed with a call to <a class="el" href="structwl__event__source.html#a0164a47e9e8356af90c9d5c1de9f5487" title="Arm or disarm a timer. ">wl_event_source_timer_update()</a> before it can trigger a dispatch call.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a59bc490bf28b48e0af908ab91649938a" title="Timer dispatch function type. ">wl_event_loop_timer_func_t</a> </dd></dl>

</div>
</div>
<a id="aa079264c57dd12168c691c000724efcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa079264c57dd12168c691c000724efcf">&#9670;&nbsp;</a></span>wl_event_source_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wl_event_source_check </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark event source to be re-checked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The event source to be re-checked.</td></tr>
  </table>
  </dd>
</dl>
<p>This function permanently marks the event source to be re-checked after the normal dispatch of sources in <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a>. Re-checking will keep iterating over all such event sources until the dispatch function for them all returns zero.</p>
<p>Re-checking is used on sources that may become ready to dispatch as a side-effect of dispatching themselves or other event sources, including idle sources. Re-checking ensures all the incoming events have been fully drained before <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a> returns. </p>

</div>
</div>
<a id="afe73f9ff59d489e9f27eb9c0e3058a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe73f9ff59d489e9f27eb9c0e3058a02">&#9670;&nbsp;</a></span>wl_event_source_fd_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_event_source_fd_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a file descriptor source's event mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The file descriptor event source to update. </td></tr>
    <tr><td class="paramname">mask</td><td>The new mask, a bitwise-or of: <code>WL_EVENT_READABLE</code>, <code>WL_EVENT_WRITABLE</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl>
<p>This changes which events, readable and/or writable, cause the dispatch callback to be called on.</p>
<p>File descriptors are usually writable to begin with, so they do not need to be polled for writable until a write actually fails. When a write fails, the event mask can be changed to poll for readable and writable, delivering a dispatch callback when it is possible to write more. Once all data has been written, the mask can be changed to poll only for readable to avoid busy-looping on dispatch.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structwl__event__source.html#a0e7ce1f52dfe04c73b6a7c2263c7ef25" title="Create a file descriptor event source. ">wl_event_loop_add_fd()</a> </dd></dl>

</div>
</div>
<a id="afe37015d67b81ae82609f2b8aa78cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe37015d67b81ae82609f2b8aa78cc4f">&#9670;&nbsp;</a></span>wl_event_source_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_event_source_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an event source from its event loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The event source to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero.</dd></dl>
<p>The event source is removed from the event loop it was created for, and is effectively destroyed. This invalidates <code>source</code> . The dispatch function of the source will no longer be called through this source. </p>

</div>
</div>
<a id="a0164a47e9e8356af90c9d5c1de9f5487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0164a47e9e8356af90c9d5c1de9f5487">&#9670;&nbsp;</a></span>wl_event_source_timer_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wl_event_source_timer_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structwl__event__source.html">wl_event_source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arm or disarm a timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The timer event source to modify. </td></tr>
    <tr><td class="paramname">ms_delay</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure.</dd></dl>
<p>If the timeout is zero, the timer is disarmed.</p>
<p>If the timeout is non-zero, the timer is set to expire after the given timeout in milliseconds. When the timer expires, the dispatch function set with <a class="el" href="structwl__event__source.html#a39374f19a73472f63fab4267a14adc10" title="Create a timer event source. ">wl_event_loop_add_timer()</a> is called once from <a class="el" href="structwl__event__loop.html#aaa3fdd5590365a4a2106c9814ca9b31b" title="Wait for events and dispatch them. ">wl_event_loop_dispatch()</a>. If another dispatch is desired after another expiry, <a class="el" href="structwl__event__source.html#a0164a47e9e8356af90c9d5c1de9f5487" title="Arm or disarm a timer. ">wl_event_source_timer_update()</a> needs to be called again. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="wayland-server-core_8h_source.html">wayland-server-core.h</a></li>
<li>/dev/shm/libwayland/wayland/src/<a class="el" href="event-loop_8c.html">event-loop.c</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 6 2018 13:02:11 for Wayland Server API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
